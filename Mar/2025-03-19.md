
#### 날짜: 2025-03-19

## 스크럼

학습 목표 1 : JPA 동작 원리 및 성능 최적화 기법 정리하기  
학습 목표 2 : 연관관계 매핑 전략과 상속 매핑 전략의 장단점 파악하기

---

### 주제 1: JPA 동작 원리

#### 엔티티 매니저와 영속성 컨텍스트

- **엔티티 매니저**: 영속성 컨텍스트를 제어하며 엔티티의 등록/조회/수정/삭제를 담당
- **영속성 컨텍스트**: 1차 캐시, 변경 감지(Dirty Checking), 지연 로딩(Lazy Loading) 등 제공  
→ SQL 작성 부담을 줄이고 성능 최적화 가능

#### 쓰기 지연 vs 배치 처리

- **쓰기 지연**: 트랜잭션 단위에서 변경 사항을 모아 커밋 시 일괄 처리
- **배치 처리**: 대량의 데이터를 한꺼번에 처리하는 전략. 쓰기 지연은 기본, 배치 처리로 성능 개선 가능

#### 트랜잭션 관리

- 엔티티 변경은 반드시 `@Transactional` 범위 내에서 수행되어야 함

---

### 주제 2: 로딩 전략

#### 지연 로딩 (Lazy)

- 연관된 엔티티를 실제 사용 시점에 조회
- 장점: 초기 로딩 최소화 → 메모리/쿼리 비용 절감
- 단점: N+1 문제 발생 가능

#### 즉시 로딩 (Eager)

- 엔티티 로딩 시 연관 엔티티도 즉시 로딩
- 장점: 즉각적인 참조 가능
- 단점: 예기치 않은 SQL 증가로 성능 예측 어려움 → 지양

> **실무에서는 기본적으로 Lazy 설정 후, 필요 시 JPQL Fetch Join 또는 Entity Graph 사용 권장**

---

### 주제 3: 캐시 전략

#### 1차 캐시

- 동일 트랜잭션 내 PK로 조회 시 DB 접근 없이 캐시 활용
- 변경 사항을 쓰기 지연 버퍼에 저장 후 커밋 시 일괄 반영

#### 2차 캐시

- EntityManagerFactory 단위의 공유 캐시
- 읽기 전용, 자주 변경되지 않는 데이터에 적합
- 주의: 동시성 제어, 캐시 무효화 전략 필요

---

### 주제 4: 연관관계 매핑 전략

#### 일대일 (@OneToOne)

- 단방향: 주 테이블이 외래 키 보유, `@JoinColumn` 사용
- 양방향: 한 쪽은 `mappedBy`, 순환 참조 주의 → `@JsonIgnore` 등 필요

#### 일대다 (@OneToMany)

- 단방향: 외래 키가 반대 테이블에 있어 비효율적 → 실무에서 사용 지양
- 양방향: `@ManyToOne` + `@JoinColumn`이 연관 관계의 주인  
→ `@OneToMany(mappedBy = "xxx")`로 설정

> 컬렉션 필드 초기화(`new ArrayList<>()`) 및 Set 사용 고려

#### 다대일 (@ManyToOne)

- 실무에서 가장 많이 사용
- `@JoinColumn`은 Many 쪽에 위치 → 외래 키 관리

#### 다대다 (@ManyToMany)

- 사용 지양  
→ 중간 엔티티를 만들어 `@OneToMany` + `@ManyToOne`으로 나누어 설계

---

### 주제 5: JPQL vs Native Query

- **JPQL**: 테이블이 아닌 엔티티와 필드를 대상으로 하는 객체 중심 쿼리 언어
```java
@Query("SELECT p FROM Product p WHERE p.price > :minPrice")
List<Product> findExpensive(@Param("minPrice") int minPrice);
```

- **Native Query**: DB 전용 SQL 사용, 복잡한 쿼리/DB 특화 기능에 적합  
→ 성능 이슈가 있는 경우에 보완책으로 활용

---

### 주제 6: Entity Graph

- JPQL 없이 Fetch 전략 지정 가능
- `@EntityGraph`를 통해 연관 엔티티 즉시 로딩 설정 가능  
→ 간결한 N+1 해결 방법
- `@NamedEntityGraph`로 정적 그래프 사전 정의 가능  
→ 동적 전략에는 한계, 복잡한 상황에서는 JPQL Fetch Join 활용이 더 유연함

---

### 주제 7: 상속 매핑 전략

#### Table per Class

- 자식마다 독립된 테이블, 부모 필드 포함
- 쿼리 복잡, 성능 낮음

#### Single Table

- 하나의 테이블에 모두 저장, DTYPE 구분 컬럼 포함
- 쿼리 성능 좋음, 테이블이 복잡해질 수 있음

#### Joined Table

- 부모/자식 테이블 분리, JOIN으로 조회
- 가장 일반적으로 사용, 정규화 구조  
→ 성능은 Single Table보다 낮을 수 있음

---

### 오늘의 회고

오늘은 JPA의 내부 동작 원리를 구조적으로 정리하며, 단순한 CRUD를 넘어 실제 서비스 개발 시 고려해야 할 성능 이슈와 설계 전략까지 정리할 수 있었다.  
특히, 지연 로딩과 즉시 로딩의 차이, 캐시 전략(1차/2차), 연관관계 매핑 방식에 따른 성능 차이는 실무에서 반드시 알고 넘어가야 할 포인트였다.

또한 Entity Graph, Fetch Join, Native Query 등 JPA의 성능 최적화 도구들도 목적과 상황에 맞게 적절히 활용해야 한다는 점에서, 단순 문법 암기보다 개념적 이해와 선택 기준이 훨씬 중요하다는 걸 느꼈다.  
앞으로는 연관관계 설계 시 항상 Lazy 로딩을 기본으로 두되, 성능을 고려한 튜닝 전략을 미리 생각해두는 습관을 길러야겠다.
