#### 날짜: 2025-03-05

## 스크럼

학습 목표 1 : 오늘 배운 내용 복습하기  
학습 목표 2 : TIL 정리하기  

⠀  

### 주제 1: 트리(Tree)

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **트리(Tree)** | 계층적인 데이터 구조로, 부모-자식 관계를 형성하는 비선형 자료구조 |  |
| **이진 탐색 트리 (BST)** | 각 노드의 왼쪽 자식 노드는 작은 값, 오른쪽 자식 노드는 큰 값을 가지는 트리 | 리밸런싱이 없으면 한쪽으로 치우칠 수 있음 |
| **B-tree** | 균형을 유지하며 다중 자식 노드를 가질 수 있는 트리 | DB 인덱스에서 자주 사용, 대용량 데이터 처리에 유리 |
| **B+tree** | 키를 기반으로 데이터를 식별하며 리프 노드에만 데이터 저장 | 리밸런싱을 자동으로 수행, ISAM(색인 순차 접근 방식) 사용 |

⠀  

### 주제 2: 인덱스(Index)

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **인덱스** | 검색 속도를 향상시키기 위해 데이터베이스에서 사용하는 구조 | LIKE '%검색어'는 인덱스를 타지 않음 |
| **클러스터형 인덱스** | 데이터가 물리적으로 정렬되어 저장되는 인덱스 | 기본 키(PK) 설정 시 자동 생성 |
| **비클러스터형 인덱스** | 인덱스와 데이터가 분리되어 있으며, 인덱스 페이지에서 데이터 위치를 참조 | 별도의 저장 공간 필요, 다양한 조건으로 인덱스 생성 가능 |
| **카디널리티** | 컬럼에서 고유한 값의 개수 | 높은 카디널리티 컬럼을 인덱스로 선택하는 것이 유리 |

⠀  

### 주제 3: 트랜잭션(Transaction)

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **트랜잭션** | 데이터베이스에서 하나의 논리적 작업 단위 | 암시적 트랜잭션(쿼리 수행 시 자동 생성), 명시적 트랜잭션(START TRANSACTION) |
| **Active** | 트랜잭션 실행 상태 |  |
| **Partially Committed** | 일부 작업이 완료된 상태 | 롤백 가능 |
| **Aborted** | 트랜잭션이 취소된 상태 | `ROLLBACK` 수행 가능 |
| **Committed** | 모든 작업이 완료되어 DB에 반영된 상태 |  |
| **분산 트랜잭션** | 여러 DB 또는 시스템에 걸쳐 수행되는 트랜잭션 | MSA 환경에서 필수 |

⠀  

### 주제 4: ACID 원칙

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **Atomicity(원자성)** | 트랜잭션이 모두 수행되거나 전혀 수행되지 않아야 함 |  |
| **Consistency(일관성)** | 데이터가 항상 일관성을 유지해야 함 | 제약 조건을 만족해야 함 |
| **Isolation(독립성)** | 트랜잭션 간 서로 영향을 주지 않아야 함 | Read Committed, Repeatable Read, Serializable |
| **Durability(지속성)** | 트랜잭션이 완료되면 결과가 영구적으로 저장되어야 함 |  |

⠀  

### 주제 5: NoSQL

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **NoSQL** | SQL 기반이 아닌 데이터베이스 유형 | 스키마 유연함, 수평 확장 가능 |
| **키-값 저장소** | 키를 기반으로 값을 저장하는 방식 | Redis, DynamoDB 사용 |
| **문서 지향 DB** | JSON, XML 기반으로 데이터를 저장 | MongoDB 사용 |
| **컬럼 기반 DB** | 열 단위로 데이터를 저장하는 방식 | Cassandra, 시계열 데이터 처리에 적합 |
| **그래프 DB** | 데이터 간 관계를 그래프 형식으로 저장 | Neo4j, 관계 분석에 강점 |

⠀  

### 주제 6: CAP 이론

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **Consistency(일관성)** | 모든 노드가 같은 데이터를 가져야 함 |  |
| **Availability(가용성)** | 모든 요청이 응답을 받을 수 있어야 함 |  |
| **Partition Tolerance(네트워크 분할 허용)** | 네트워크 장애 발생 시에도 시스템이 동작해야 함 | CAP 이론에 따르면 세 가지 중 두 가지만 충족 가능 |

⠀  

### 주제 7: 객체지향 개념

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **캡슐화** | 내부 데이터를 외부에서 직접 접근하지 못하도록 보호하는 개념 | 정보 은닉, 접근제어자 사용 (private, protected, public) |
| **상속** | 기존 클래스의 속성과 동작을 물려받아 새로운 클래스를 만드는 것 | 코드 재사용성 증가, `extends` 키워드 사용 |
| **다형성** | 같은 이름의 메서드라도 객체 타입에 따라 다르게 동작하는 것 | 코드 확장성과 유연성 증가 |
| **추상화** | 시스템의 핵심 기능만 노출하고, 세부 사항은 숨기는 것 | 인터페이스, 추상 클래스 활용 |

⠀  

### 주제 8: 프레임워크 vs. 라이브러리

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| **프레임워크** | 개발자가 따를 수 있는 일관된 구조 제공 | 리액트, 스프링, Django |
| **라이브러리** | 특정 기능을 제공하는 코드 모음 | jQuery, Lodash |

⠀  

### 오늘의 회고

오늘은 데이터베이스 관련 개념을 정리하면서, 인덱스와 트리 구조의 차이를 다시 한 번 명확히 이해할 수 있었다. 특히 NoSQL과 CAP 이론을 정리하면서, 단순히 "NoSQL은 RDBMS보다 유연하다"는 설명만으로는 부족하다는 것을 깨달았다. 실제로 서비스 아키텍처를 설계할 때 어떤 특성을 우선순위로 둬야 하는지 고민해야 한다는 점이 흥미로웠다.

객체지향 개념도 다시 정리하면서, 추상화와 다형성이 실제 개발에서 어떻게 적용되는지 고민해볼 필요가 있음을 느꼈다. 너무 깊게 들어가면 복잡성이 증가할 수 있지만, 적절한 수준에서 객체지향 원칙을 적용하는 것이 중요하다는 점을 다시 한 번 상기하게 된 하루였다.

