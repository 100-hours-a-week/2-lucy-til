
#### 날짜: 2025-03-18

## 스크럼

학습 목표 1 : JPA의 핵심 개념과 ORM의 이점 및 한계 정리하기  
학습 목표 2 : 영속성 컨텍스트와 엔티티 생명주기 이해하기

---

### 주제 1: JPA와 ORM 개념 정리

| 개념 | 정의 | 비고 |
| --- | --- | --- |
| JPA | 자바에서 ORM을 구현하기 위한 표준 명세 | - 엔티티와 테이블 간 매핑 규칙 제공<br>- 영속성 컨텍스트 개념(1차 캐시, Dirty Checking, 지연 로딩 등)<br>- 트랜잭션 처리 및 쿼리 처리 방식 정의<br>- JPA는 인터페이스이며, Hibernate는 그 구현체 |
| ORM | 객체를 관계형 데이터베이스와 자동으로 매핑해주는 기술 | **이점**<br>1. SQL 작성 감소<br>2. 반복 코드 제거로 생산성 향상<br>3. 객체 중심 개발 가능<br>4. DB 추상화로 이식성↑<br>**한계**<br>1. 복잡한 쿼리에는 한계가 있어 native query 필요<br>2. 성능 이슈 발생 가능<br>3. 데이터 흐름 추적 어려움 |

> JPA는 객체지향 프로그래밍과 데이터베이스 간의 간극을 줄여주며, 코드의 일관성과 생산성을 높여주는 도구이다. 하지만 그만큼 내부 동작 방식에 대한 이해가 중요하다.

---

### 주제 2: 영속성 컨텍스트

| 개념 | 정의 | 설명 |
| --- | --- | --- |
| 영속성 컨텍스트 | DB가 아닌 논리적 개념으로, 엔티티의 상태를 관리하는 환경 | - 트랜잭션 범위 내에서 작동 (`@Transactional`)<br>- 엔티티 생명주기를 관리하며 1차 캐시, 변경 감지, 지연 로딩 등을 제공<br><br>**1차 캐시**: 동일 트랜잭션 내 동일 PK 조회 시 캐시 활용<br>**변경 감지(Dirty Checking)**: 객체의 필드가 변경되면 트랜잭션 커밋 시점에 자동으로 UPDATE<br>**지연 로딩(Lazy Loading)**: 연관된 엔티티를 실제 사용할 때 조회<br>**쓰기 지연(Write-behind)**: 쿼리를 바로 보내지 않고 모아뒀다 커밋 시 처리 |

> 영속성 컨텍스트는 단순히 DB 연결 이상의 의미를 가지며, 엔티티의 상태 변화와 트랜잭션 처리에 핵심적인 역할을 한다.

---

### 주제 3: 엔티티 생명주기

| 상태 | 설명 |
| --- | --- |
| 비영속 | 단순히 new로 생성된 객체, 영속성 컨텍스트와 무관 |
| 영속 | `persist()` 등을 통해 영속성 컨텍스트에 등록된 상태 |
| 준영속 | 컨텍스트에서 분리된 상태 (`detach()` 등), 더 이상 변경 감지나 로딩 불가 |
| 삭제 | `remove()` 호출 후 트랜잭션 커밋 시 실제 DB에서 삭제됨 |

---

### 주제 4: 엔티티 매니저(EntityManager)

- JPA의 핵심 API로, 엔티티의 저장, 조회, 수정, 삭제 등을 수행
- 트랜잭션 단위로 동작하며, 요청-응답 범위에서 사용됨
- 스레드 세이프하지 않음 → 멀티스레드 환경에서는 주의 필요

---

### 오늘의 회고

오늘은 JPA의 핵심 개념과 ORM의 기본 철학을 다시 한 번 정리할 수 있었다.  
특히, JPA가 단순히 SQL을 대체하는 도구가 아니라 객체 중심으로 설계를 이끌고, 생산성을 향상시키며, 코드 품질을 높이기 위한 프레임워크라는 점을 다시 인식하게 되었다.
영속성 컨텍스트는 개념적으로 다소 어렵지만, 1차 캐시, 변경 감지, 지연 로딩 등 JPA의 주요 기능들이 이 컨텍스트를 기반으로 작동하기 때문에 꼭 이해하고 넘어가야 할 핵심이라고 생각했다.  
엔티티의 생명주기나 EntityManager의 작동 방식도 실무에서 자주 마주치게 될 개념이라, 오늘 정리한 내용을 반복해서 복습하고 직접 구현해보며 감을 익혀야겠다.  
그리고 항상 중요한 것은 기술은 그 기술의 등장 의의가 있다는 것이다.  
이 기술이 왜 존재하는지, 그리고 그 전에는 어떤 기술이 존재했는지 시대의 흐름을 인식할 수 있는 개발자가 되고 싶다.  

