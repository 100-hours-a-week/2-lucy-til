
#### 날짜: 2025-03-20

## 스크럼

학습 목표 1 : N+1 문제의 원인과 해결 전략 정리하기  
학습 목표 2 : QueryDSL과 동적 쿼리 작성 방식의 차이 이해하기

---

### 주제 1: N+1 문제

- **정의**: 하나의 쿼리를 실행했을 때, 연관된 N개의 엔티티를 조회하는 추가 쿼리가 발생하는 현상
- **원인**: 객체지향과 관계형 DB 패러다임의 불일치 (특히 Lazy Loading 사용 시)

---

### 해결책

#### 1. **페치 조인 (JOIN FETCH)**

- 연관 엔티티를 한 번에 조인하여 로드
- 장점: 한 번의 쿼리로 모든 데이터를 조회
- 단점: Lazy 설정 무시됨, 여러 컬렉션 동시 조인 불가, 중복 가능성

#### 2. **배치 사이즈 (@BatchSize)**

- Lazy 로딩을 유지하면서 IN절로 묶어 조회
- 장점: N → N / batch 크기로 쿼리 수 감소
- 단점: 적절한 사이즈 튜닝 필요, `max_allowed_packet` 제한 고려

#### 3. **FetchMode.SUBSELECT**

- Hibernate 전용 기능으로 Subselect로 묶음 로딩
- 장점: 다수의 부모 엔티티에 대해 한 번에 하위 엔티티 로딩
- 단점: 쿼리 복잡도 증가 가능, 실데이터 환경에서 성능 테스트 필요

> **전략 추천**: 주 엔티티는 페치 조인, 서브 컬렉션은 서브셀렉트/배치 사이즈로 혼합 구성

---

### 주제 2: QueryDSL

- **정의**: 문자열 없이 타입 안정성 있는 JPQL을 작성할 수 있도록 도와주는 자바 기반 DSL
- **장점**:
  - 타입 안정성: 컴파일 타임 오류 방지 (Q-class 사용)
  - IDE 자동완성, 메서드 체이닝
  - 가독성 및 유지보수성 우수
- **단점**:
  - 초기 학습 비용
  - Q파일 생성에 따른 빌드 시간 증가

#### 사용 예시

```java
@Query("SELECT p FROM Product p WHERE p.price > :minPrice")
List<Product> findExpensive(@Param("minPrice") int minPrice);
```

- 내부적으로 JPQL로 변환되어 실행됨
- select * 지양, 명시적 select 사용 권장
- Q파일은 @Generated → 수동 수정 금지

---

### 주제 3: 동적 쿼리

#### BooleanBuilder 방식

- 조건을 순차적으로 조립
- 장점: 직관적
- 단점: 조건이 많아지면 가독성 저하

#### Where 절 체이닝

- null-safe 체이닝 방식
- 장점: 재사용성 높고 코드 간결

#### BooleanExpression

- 더 복잡하고 정교한 조건 조합 가능

> **조건문 많을 때**: Dto 기반 또는 헬퍼 메서드 활용

---

### 주제 4: 주의 사항 및 실무 팁

- **묵시적 조인 지양**: 의도치 않은 cross join → 항상 명시적 조인 사용
- **조인 조건 위치**: 
  - `WHERE`: inner join 이후 필터링
  - `ON`: join 시점에 row 자체를 제한

- **엔티티 직접 반환 지양**: 
  - 영속성 컨텍스트로 인해 Lazy Loading 발생
  - DTO로 안전하게 반환
  - `@QueryProjection`: 안정성↑, 종속성도↑

- **실무 실수 예시**
  - `.equalsIgnoreCase()` → `lower() + eq()` 로 변환
  - `equals` 대신 QueryDSL `eq()` 사용

---

### 오늘의 회고

오늘은 성능 최적화의 핵심인 N+1 문제를 중심으로 다양한 해결 전략을 정리했다.  
사실 프로젝트하면서 마주쳤던 문제들이라 조금 더 관심이 갔다.  
내 해결책과 이상적인 해결 가이드를 비교해보며 나의 삽질이 결코 헛되지 않음을 알 수 있었다.  
앞으로도 열심히 삽질을 해서 많은 모래들을 품에 안고 싶다.  

