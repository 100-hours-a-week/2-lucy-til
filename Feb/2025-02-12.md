#### 날짜: 2025-02-12

## 스크럼

학습 목표 1 : 오늘 배운 내용 복습하기  
학습 목표 2 : TIL 정리하기  



⠀  


### 주제 1: 클라이언트 / 서버  
클라이언트는 서버에 데이터나 서비스를 요청하는 브라우저 또는 프로그램이고, 서버는 클라이언트에게 요청을 받아 응답하는 컴퓨터 혹은 프로그램이다.  
보안이 필요한 경우, 클라이언트와 서버는 인증과 인가를 통해 서비스를 요청하고 제공받는다.  
인증이란 사용자의 신원을 확인하는 과정이다.  
인가란 신원을 확인한 사용자의 접근 권한을 확인하는 과정이다. 
예를 들어, 로그인할 때 아이디와 비밀번호를 입력하면 인증이 되고,  
로그인 후 관리자인지 일반 사용자인지에 따라 접근할 수 있는 기능이 다르면 이는 인가의 과정이다.  

<hr>
한편 일반적인 웹에서 클라이언트가 유튜브 주소를 입력할 때의 통신 과정은 다음과 같다.  
클라이언트는 웹사이트에 URL을 입력한다.  
DNS는 계층적으로 동작하며 브라우저, 로컬 캐시, ISP DNS 서버, 루트 네임 서버 등을 거쳐 IP를 찾는다.  
캐싱이 적용되면 동일한 요청을 보낼 때 더 빠른 응답을 받을 수 있다.  
클라이언트와 서버는 TCP 3-handshake를 통해 서로의 존재를 확인한다.  
서버는 CA가 서명한 TLS 인증서를 제공하며, 클라이언트는 이를 검증하여 신뢰할 수 있는 지 확인한다.  
클라이언트는 서버의 인증서를 확인하고 TLS 핸드셰이크 과정에서 RSA, ECDH 등의 방법을 통해 대칭키를 안전하게 공유한다.  TLS 핸드셰이크를 통해 생성된 대칭키를 사용하여 암호화된 데이터 통신을 진행한다.  
서버는 클라이언트 요청을 처리한 후, 응답과 함께 HTTP 상태 코드를 반환한다.  
200(정상), 404(페이지 없음), 500(서버 오류) 등이 있다.  
브라우저는 서버로부터 응답과 리소스를 받아 렌더링 과정을 거쳐 화면을 띄우고 클라이언트는 웹사이트에 접속할 수 있게 된다.  



### 주제 2: TCP / UDP
TCP/UDP는 전송 계층에 위치한 전송 프토토콜이다.  
TCP는 연결 지향적이며 신뢰성을 보장하는 프로토콜이다.  
TCP는 흐름 제어를 통해 수신자의 버퍼가 초과되지 않도록 데이터를 조절하고, 혼잡 제어를 통해 네트워크 부하를 조정한다.  
송신자와 수신자는 3-핸드셰이크를 통해 서로를 확인하고, 사용자는 수신자의 수신 여부를 확인하며 순차적으로 데이터를 전송한다. 
한 번에 하나의 패킷을 보내고 응답을 받으면 다음 패킷을 전송하는 Stop-and-wait과  
여러 개의 패킷을 미리 보내고 수신 확인을 받으면 윈도우 크기를 조절하는 Sliding Window가 있다.  
또한 TCP는 혼잡 제어를 통해 네트워크가 과부하가 되지 않도록 송신 속도를 조절한다.  
점차 윈도우 크기를 증가시키며 전송하거나, 윈도우 크기를 천천히 증가시키거나 만약 패킷 손실이 발생하면 재전송을 수행하는 것이 혼잡 제어에 해당한다.  
TCP는 패킷마다 시퀀스 넘버를 부여하여 수신자가 데이터를 순서대로 조합할 수 있도록 한다.  
일반적인 다운로드가 TCP의 예시이다.  
반면 UDP는 비연결형이며 신뢰성을 보장하지 않지만 속도가 빠른 프로토콜이다.  
UDP는 수신자의 수신 여부를 확인하지 않으므로 패킷 손실이 발생할 수 있다.  
데이터의 누락이 존재할 수 있지만 빠르다는 것이 장점이다.  
실시간 스트리밍, 게임 등에 적용되고는 한다.  
그러나 UDP를 DNS 조회, 스트리밍, VolP 등에서 단독으로 사용되기도 하지만, 신뢰성을 보완하기 위해 QUIC 같은 프로토콜이 개발되었다.  


  

### 주제 3: HTTPS
HTTP는 구조화된 텍스트를 전송하는 프로토콜이다.  
HTTPS는 HTTP에 암호화와 인증을 강화한 프로토콜이다.  
자세히 이야기하자면, TLS를 이용해 기밀성, 무결성, 인증을 제공한다.  
HTTPS의 동작 방식은 다음과 같다.  
클라이언트가 서버에 ClientHello 메세지를 보낸다.  
이 메세지에는 클라이언트가 지원하는 암호화 방식이 포함된다.  
서버는 ServerHello와 함께 자신의 TLS 인증서를 전송한다.
클라이언트는 TLS의 인증이 유효한지 확인한다.  
만약 TLS 인증이 유효하지 않을 경우 브라우저에 인증되지 않은 홈페이지라고 뜬다.  
만약 인증이 유효하다면 클라이언트와 서버는 키 교환을 진행한다.  
RSA 방식일 경우 클라이언트가 난수를 생성하고, 이를 서버의 공개키로 암호하여 전송한 후 해당 난수를 기반으로 세션 키를 생성한다.  
ECDH 방식일 경우 클라이언트와 서버가 서로 공개키를 교환한 후 Diffie-Hellman 알고리즘을 사용하여 세션키를 안전하게 생성한다.  
TLS 핸드셰이크를 통해 세션키를 공유한 둘은 이후 대칭키 암호화 방식으로 안전한 데이터 통신을 진행한다.  




### 주제 4: 캐싱
캐싱이란 리소스를 미리 저장해두고 이에 대한 접근 시 바로 사용하는 것을 의미한다.  
그 중에서도 HTTP Cache는 웹 사이트의 데이터나 정보를 캐시해두는 것을 말한다.  
이외에도 캐싱은 데이터를 저장하는 위치에 따라 브라우저 캐시, CDN 캐시, 서버 캐시, 데이터베이스 캐시 등으로 나뉜다. 
HTTP 캐싱 전략에는 Freshness와 Validation 방식이 있다.  
Freshness는 Cache-Control, Expires 헤더를 사용하여 정해진 기간동안 캐시를 재사용한다.  
Cache-Control이 우선적으로 적용된다.  
Validation은 ETag, Last-Modified를 이용하여 기존 캐시가 유효한지 검증하고 필요하다면 서버에서 최신 데이터를 확인하여 업데이트한다.  
또한 캐시 무효화가 필요할 때가 있다.  
서버에서 중요한 데이터가 변경되었을 경우 버전 번호 변경 또는 time to live 설정, 캐시 삭제를 통해 새로운 데이터를 불러오게 할 수 있다.  
클라이언트가 페이지에 접속하면, 브라우저는 캐시에 관련 정보가 존재하는지를 확인한다.  
이때 유효 기간 내의 캐시가 존재하면 브라우저는 해당 캐시를 화면에 바로 그린다.  
그러나 유효 기간이 지나면 브라우저는 먼저 캐시된 데이터를 사용할 수도 있지만 그와 동시에 서버에 최신 데이터를 요청하여 백그라운드로 데이터를 갱신한다.  
대표적으로 뉴스 기사 댓글, 포럼 등에 달린 댓글에 캐싱이 사용된다.  


### 주제 5 : REST API
REST API란 REST 아키텍처 스타일을 따르는 API이다.  
이들은 일관된 인터페이스, 무상태성, 캐시 가능성, 클라이언트-서버 구조, 계층 구조, 선택적 코드 실행의 6가지 원칙을 기반으로 한다.  
일관된 인터페이스는 요청 방식(GET, POST), URI 디자인 방식 등이 일관되어야 한다는 것이다.  
무상태성은 서버는 클라이언트의 세션 상태를 저장하지 않고, 각 요청이 독립적으로 처리된다는 것을 의미한다.  
따라서 클라이언트가 필요한 모든 정보를 요청과 함께 전송해야 하며, 로그인 상태를 유지를 위해 JWT 같은 토큰 기반 인증 방식을 사용할 수 있다.  
캐시 가능성은 REST API의 응답이 캐싱될 수 있도록 설계되어야 하며,이를 통해 성능을 향상하고 불필요한 네트워크 트래픽을 줄일 수 있어야 한다.  
계층 구조는 중간에 프록시나 게이트웨이를 둘 수 있지만 클라이언트는 엔드단만을 인식하고 있어야 한다는 것이다.  
선택적 코드 실행이란 필요할 경우 서버가 클라이언트에 실행 가능한 스크립트를 제공할 수 있음을 의미한다. 하지만 대부분의 REST API 설계에서는 이 원칙을 사용하지 않는다.  


REST API의 사용 방식은 GET users/{id}와 같이 요소를 명사로 나타냄과 동시에 소문자로, 계층화하며 HTTP 메소드를 통해 리소스를 조작하는 것이 필수적이라고 할 수 있다.  

⠀  

### 오늘의 회고
완벽하게 정리해내야 한다는 부담감이 커진다.  
이전 내용을 거듭해서 열심히 공부하면 공부할수록 새로이 배우거나 복습하는 개념 또한 완벽히 머리 속에 들어가야 된다는 강박이 생겼다.  
분량이 워낙 많은 부분이면 그것이 더욱 심하다.  
스스로의 불안을 조절할 줄 알아야 한다. 
한 번에 모든 것을 정복하려고 하지말고 반복해서 들여다보자.  




