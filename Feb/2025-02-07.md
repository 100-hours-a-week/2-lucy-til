#### 날짜: 2025-02-07

## 스크럼

학습 목표 1 : 오늘 배운 내용 복습하기(완료)        


⠀  


### 주제 1: 스레드와 스레드 풀
 
스레드란 프로그램이나 프로세스 내에서의 실행 흐름 단위를 의미한다. 여러 스레드를 사용하는 멀티스레딩 기법을 이용하면 동시성을 통해 프로그램의 성능과 효율성을 높일 수 있다. 동시성이란 하나의 CPU에서 여러 작업간 빠른 전환과 실행을 통해 마치 여러 개의 작업을 동시에 진행하는 것처럼 보이게 하는 개념이다. 이렇게 동시성을 달성하는 과정에서 진행 중이던 작업을 저장하고 전환하며 실행하는 것을 컨텍스트 스위칭이라고 한다.  
그러나 멀티 스레드 환경에서 스레드의 수나 컨텍스트 스위칭이 자주 발생할 경우 컨텍스트 스위칭 오버헤드가 발생할 수 있으며 이것이 누적될 경우 프로그램의 성능에 영향을 줄 수 있다. 이러한 오버헤드를 줄이기 위해서 등장한 것이 스레드 풀이다. 스레드 풀은 사전에 일정 개수의 스레드를 생성하고 필요할 때마다 이를 할당하여 재사용할 수 있다. 그러나 스레드 풀 역시 OS 레벨에서 스레드를 생성하고 관리하기 때문에 여전히 컨텍스트 스위칭이나 스레드 생성 오버헤드가 존재할 수 있다.
⠀  


### 주제 2: 스레드의 라이프 사이클과 데드락

스레드는 New -> Runnable -> Running -> (Blocked, Waiting, Time Waiting -> Runnable -> Running) ->  Terminated의 라이프 사이클을 가진다. 이때 New는 Thread 객체가 new 객체로 생성된 상태를 의미한다. Runnable은 start 메소드가 실행된 상태이고, Running은 start 메소드 실행 후 실제로 CPU가 배정된 상태를 의미한다. Blocked과 Waiting, Time Waiting은 모두 대기 상태를 의미하는데 Waiting은 상대의 notify 메소드를 기다리는 것이고 Time Waiting은 sleep 등에 일정 시간 동안 대기하는 것을 명시하여 사용한다. 그리고 Blocked은 상대가 점유한 공유 자원의 할당을 위해 대기하는 것인데 바로 이때 데드락이 발생할 수 있다.  
데드락은 Coffman의 4가지 조건인 점유 대기, 상호 배제, 환형 대기, 비선점이 모두 충족되는 상황에서 발생한다.
이러한 데드락은 크게 OS 레벨과 애플리케이션 레벨에서 각각 해결할 수 있다.  
OS 레벨의 경우 Coffan의 4가지 조건 중 하나 이상을 직접 해소하여 데드락을 해결하는 것이다. 그러나 점유 대기는 자원의 낭비, 상호 배제는 공유 자원 한정으로만 적용할 수 있다는 한계가 존재하여 환형 대기를 해소하거나 비선점을 해소하는 방식이 권장된다.  
애플리케이션 레벨에서 데드락을 해소하는 방법은 락을 이용하는 것이다. 락이란 여러 개의 스레드가 하나의 공유 자원에 동시에 접근하는 것을 방지하는 기본적인 개념이다. 이러한 락의 개념 하에 도입된 뮤텍스, 세마 포어 등을 사용하여 데드락을 해소할 수 있다. 뮤텍스란 한 번에 하나의 스레드만 공유 자원에 접근할 수 있도록 제한하여 환형 대기를 깨뜨리는 것이고, 세마 포어는 한 번에 n개의 카운터를 통해 임계 영역에 동시에 들어갈 수 있는 스레드 수를 제한하는 것이다. 그러나 락 순서, 타임 아웃, 락 획득 방법을 세심하게 설계하지 못하면 기아 상태에 빠질 수 있다는 위험성이 있다.

⠀  

### 주제 3: 버추얼 스레드

스레드의 생성과 컨텍스트 스위칭 시 발생하는 오버헤드에 대한 대안점으로 제시된 스레드 풀의 경우 여전히 OS 레벨에서 커널이 직접 스레드를 생성하고 관리하여 비용이 높다는 단점이 있었다. 때문에 스레드의 생성과 관리를 사용자 수준에서 진행하고자 등장한 것이 버추얼 스레드이다.
자바에서는 JDK 21 이후 Project Loom이라는 형태로 버추얼 스레드가 등장했다. Project Loom은 스레드 생성과 컨텍스트 스위칭 비용이 거의 0에 가까우며 이러한 빠른 작업 속도로 인해 비동기 프로그래밍의 사용이 거의 요구되지 않는다는 장점이 있다. 그러나 이들은 모두 애플리케이션 레벨에서 동작하기 때문에 실제 OS는 여러 개의 버추얼 스레드를 하나의 단일 스레드로 인식하며, 하나의 스레드가 Blocked될 경우 전체 스레드가 중단될 수 있다는 위험성이 있다. 최근에는 Thread 클래스가 확장되면서 기존 Thread와 더 높은 호환성으로 버추얼 스레드를 직접 생성할 수도 있다.



⠀  

### 오늘의 도전 과제와 해결 방법

도전 과제 1: 딥다이브 모두 끝내기 -> 결국 다 끝내지 못했지만 파고들어가 보고, 내가 파고든 것을 설명할 수 있었다는 점에서 큰 뿌듯함을 느꼈다. 암기가 아니라 이해하는 것을 주안점으로 두고 시간이 오래 걸리더라도 하나씩 이해해 나가고 싶다.

⠀  

### 오늘의 회고

파고드는 것의 어려움과 성취감을 동시에 느끼는 요즘이다.  
예전에 학생들을 가르칠 때 나였으면 이 부분을 궁금해 할 것 같다를 대입해서 생각해보려니 어려움이 가득하다.  
게다가 인터넷에서 접할 수 있는 정보의 범위가 너무나도 다양해 종이 책까지 함께 참고하는 과정에서 정보의 여과의 여러움 또한 여실히 체감하고 있다.  
언어마다 버전마다 차이점을 갖고 있기 때문에 무조건적인 정답은 없을 것이라고 생각한다.  
또 다른 맥락에서도 어떤 문제에 대해 무조건적인 해결책은 없다고 느껴지는 요즘이다.  
100퍼센트 완벽한 기술은 없다는 것을 기술을 진지하게 공부해보기 시작하면서 조금씩 깨닫고 있다.  
당연한 말이지만 모든 것이 결국에는 그를 조율하는 개발자와 시스템 설계자에게 달려있다는 것이 무섭게 느껴진다.  
나는 나의 작은 프로젝트를 진행하면서도 이렇게나 걱정되는데 실제로 현업에 들어가면 나의 코드가 이상한 문제를 일으킬까봐 벌써부터 걱정이 되곤 한다.  
그 수많은 프로그램과 사이트를 지탱하고 있는 누군가의 어깨가 대단해보이는 요즘이다.  
최대한 많은 케이스를 공부하고 현업에 뛰어들고 싶다.  

